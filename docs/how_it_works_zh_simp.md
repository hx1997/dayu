**简体中文** | [English](how_it_works.md)

# 蒲篮是怎样编成的 - 工作原理
蒲篮反编译器先将字节码转换为中间表示（IR），再将 IR 转换为伪代码。此过程可分为几阶段，如下图所示：

![](imgs/decompiler_workflow_zh_simp.png)

## 阶段 1：字节码转原始 IR
本阶段的工作是解析 Panda Assembly 反汇编结果，从中提取出各条指令，并将指令存入内部的结构体中（每条指令放入一个 `NAddressCode` 中）。后续的分析和翻译只会基于这些内部结构开展。

## 阶段 2：原始 IR 转低级 IR
在本阶段中，基于原始 IR 构建控制流图（CFG），并将原始 IR 提升为低级 IR。该阶段目标是用一组有限的、标准化的 IR 指令来表示原始字节码的操作，这种统一的形式有助于分析和反编译。

从较低级语言向较高级语言转换的过程称为**提升**。对于方舟的每种操作码，我们编写一个提升函数，提升函数负责确定该条原始 IR 指令对应于哪种类型的低级 IR 指令（如赋值指令、无条件跳转指令），并相应处理其参数。然后创建一条或多条低级 IR 指令来替代原始 IR 指令，如果该条指令所表示的操作较为复杂（例如需要伪函数），则一条原始 IR 指令可能对应为多条低级 IR 指令。

低级和中级 IR 指令类似于三地址码，但函数调用可能会有多于三个参数，因此代码中将这些指令称为 `NAddressCode`，意为“N 地址码”，简称 NAC。

截至目前，有八种类型的 NAC：
- ASSIGN: 赋值语句，最多接受三个参数
- UNCOND_JUMP: 无条件跳转语句，仅接受一个参数
- COND_JUMP: 条件跳转语句，仅接受三个参数
- CALL: 函数/方法调用语句，至少接受一个参数（即函数/方法名）
- RETURN: 返回语句，仅接受一个参数
- UNCOND_THROW: 无条件抛出异常语句，仅接受一个参数
- COND_THROW: 条件抛出异常语句，仅接受三个参数
- UNKNOWN: 专为非“合式” IR 指令（指其 `NAddressCode` 中的字段非完全设置好的状态）使用，例如原始 IR 指令、伪代码指令，有时也包含某些高级 IR 指令

提升函数把原始 IR 转换为低级 IR，低级 IR 由一条条以上类型之一的 NAC 组成。例如，一条原始 IR 指令 `lda v2`（将 `v2` 赋值给 `acc`）会变成一条 `ASSIGN` 类型的 NAC，其参数为 `acc` 和 `v2`。

### IR 格式限制
为分析简便起见，低级和中级 IR 的 NAC 遵循特定的格式。完整的格式后续若有时间会另开文档说明，在此只列出大略：

- 每条 NAC 至多允许三个参数（有少许例外，下条中说明）。每种 NAC 具体允许几个参数，上文已给出。
- `CALL` 类型的 NAC 可以有多于三个参数。表达式参数（详见后文）中可以嵌套参数，例如，`v0 = (v1 + 1) + 2` 这条 NAC 中，第二个参数是表达式参数 `(v1 + 1)`，其自身又由两个参数 `v1` 和 `1` 组成。但是，该条 NAC 形式上仍被视为是三参数的（即表达式参数视为整体）。
- 参数是有顺序的，每个位置有其意义。例如，`ASSIGN` 类型的 NAC 的第一个参数总表示赋值的目的地。
- 参数一般封装在 `PandasmInsnArgument` 中，各有其类型（如 `reg` 表示寄存器参数）。
- `ExprArg` 封装表达式参数，该类型的参数允许嵌套（即表达式中含表达式，如 `(v1 + (v2 + 3))`）。为保证分析不过于复杂，每个 `arith` 类型的表达式只有一个运算符和至多两个操作数/参数。
- 属性访问视为一个 `field` 类型且带有引用对象的参数，而非两个参数。例如，`v0["set"]` 是一个 `field` 类型的参数，值为 `"set"`，引用对象是 `v0`。
- 引用对象不嵌套，即引用对象不能又是一个带引用对象的参数。这样保证形如 `acc["foo"]["bar"]` 的多重属性访问不会出现在 IR 中。
- 一条 NAC 中至多只有一个带引用对象的参数。

阶段 2 和阶段 3 的操作都特别注意不会违背上述的限制，代码中许多操作也默认以上述限制为前提。

## 阶段 3：低级 IR 转中级 IR
该阶段使用了数据流分析这一强大的工具来简化低级 IR，我们期望，得到的输出即中级 IR 既能比低级 IR 便于人类阅读，又能便于机器分析。

本阶段会遵循上文阶段 2 所述的 IR 限制，因此在流程图中有“受限数据流分析”的说法。由于受限分析具有这种保持限制的特性，因此能保证其输出能够再被用作自身或另一分析的输入。

阶段 3 主要进行两种数据流分析：活跃变量分析和死代码消除。还有一种分析称为复制传播，由于其计算复杂度较高，默认推迟到阶段 4 进行。此外还进行窥孔优化，但窥孔优化不属于数据流分析。

活跃变量分析的任务是确定程序中某一点之后哪些变量不再活跃（即不再被使用）。死代码消除基于活跃变量分析，其任务是删除结果不会被用到的那些 NAC（即所谓死代码）。例如，给定下列 NAC：

```
v1 = acc
v2 = acc
v1 = v3
```

死代码消除会删掉第一条 NAC，因为这条赋值的结果被第三条 NAC 覆盖了，所以实际上其赋值是无用的。

窥孔优化的任务是匹配代码中特定的模式，并以更简洁的形式来改写。例如，下列模式

```
a = b
b = a
```

显然是冗余的，可以改写成：

```
a = b
```

（待续）